


## 面向对象

+ 面向对象编程以数据为核心，所以在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。

+ 面向对象虽然开发效率高但是代码的运行效率比起面向过程要低很多，这也限制了面向对象的使用场景不能包括那些对性能要求很苛刻的地方。

设计模式(23)

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


 # 创建型模式
 
 ## 单例模式 （一）
 
 > 核心是：保证一个类仅有一个实例，并提供一个访问它的全局访问点
 >> 单例是一个常见的模式，一些对象我们往往只需要一个，比如线程池 全局缓存 浏览器中的window 对象
 
 
 ### 单例实例
 ```js
      var singLeton=function(name){
      this.name=name;
      this.instance=null;
     };
     singLeton.prototype.getName=function(){
      alter(this.name);
     };
     singLeton.getInstance=function(name){
      if (!this.instance) {
       this.instance=new singLeton(name)
      };
      return this.instance;

     };
     var a=singLeton.getInstance('sven1');
     var b=singLeton.getInstance('sven2');
     console.log(a==b)// true
 ```
 ### 透明的单例模式
 用户从这类中创建对象的时候，可以像使用其他任何普通类一样
 
 ``` js 
 var  creatDiv=(function(){
            var instance ;
            var creatDiv=function(html){
             if(instance){
              return instance
             };
             this.init();
             return instance=this;
            }
            creatDiv.prototype.init=function(){
                   var  div=document.createElement('div');
                   div.innerHTML=this.html;
                   document.body.appendChild(div);
                  }
             return creatDiv
  })();
  var  a= new creatDiv('sven1');
  var  b= new creatDiv('sven2');
  console.log(a===b) //true 
 ```
 ### 缓存代理的应用
 
 ```JS
            var createDiv=function(html){
            this.html=html;
            this.init();
           };
           createDiv.prototype.init=function(){
            var  div=document.createElement('div');
              div.innerHTML=this.html;
              document.body.appendChild(div);
             } ;
            proxySingDiv=(function(){
             var instance
              return function(html){
               if(!instance){
                instance=new  createDiv(html)
               }
               return instance
              }
            })();
            var a= new proxySingDiv('save1');
            var b= new proxySingDiv('save2');
           console.log(a===b)
 ```
 
 ### 通用的惰性单例 **（特别重要）**
 
```js 
var  getSingle=function(fn){
		   	var result;
		   	 return function(){
		   	 	 return result||(result=fn.apply(this,arguments));
		   	 };
   		};
var  createLoginLayer=function(){
		   	 var div =document.createElement('div');
		   	 div.innerHTML='我是登录窗';
		   	 div.style.display='none';
		   	 document.body.appendChild(div);
		   	  return div 
		   };
		   
var createSingleLoginLayer=getSingle(createLoginLayer);	// 创建登录的单例模式

var btn= document.getElementById('btn');
btn.onclick=function(){
 var loginLayer=createSingleLoginLayer();
     	 loginLayer.style.display='block'
};



```

 ## 工厂方法模式（二）
 
 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例
 
 ### 安全的工厂模式及明信片工厂
 ```js 
  var factory=function(type,content){

	    	if(this instanceof factory){
	    		var  s= new this[type](content);
	    		return s
	    	}else{
	    		return  new factory(type,content);
	    	};
	    };
	    factory.prototype={
	    	
	    	constructor:factory,//  注意点 将原型的constructor 指会。
	    	java:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	php:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	javascript:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	}
	    };

       factory('java','i am java')
 new  factory('javascript','i am php')；
 
 ```
 ## 抽象工厂模式 （三）
 + 通过对类的工厂抽象使其业务用于对产品类的创建，而不负责创建某一类产品的实例，及抽象工厂是常见子类的
 
 + **抽象类是一种申明但不能使用的类** 当你使用时就会报错  JavaScript 是灵活的，所以我们可以在类的方法中手动的抛出错误来模拟抽象类
 
 + JavaScript 中abstract 还是一个保留字 所以还不能像面向对象语言那样轻松的创建 
 
 + 抽象类的作用定义一个产品簇，并生声明一些必备的方法 如果子类中没有去重写就会抛出错误
 
 + 通过抽象工厂 我们就知道每个子类到底是哪一种类别，然后他们也具备了该类所必备的属性和方法

```js 
// 抽象工厂方法 
	    var  vehicleFactory=function(subType,superType){
	    	// 判断抽象工厂中是否有该抽象类
	    	if(typeof vehicleFactory[superType]==='function'){
	    		function F(){};
	    		F.prototype = new vehicleFactory[superType](); // 继承父类属性和方法 
	    		subType.prototype=new F();
	    		subType.constructor=subType; // 将子类的constructor 指向子类 
	    	}else{
	    		throw new Error('未创建该抽象类');
	    	};
	    };

	   // 小汽车的抽象类 
	   vehicleFactory.car=function(){
	   	this.type='car';
	   };
	   vehicleFactory.car.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getspeed:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	// 公交车的抽象类
	    vehicleFactory.bus=function(){
	   	this.type='bus';
	   };
	   vehicleFactory.bus.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getPassengerNum:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	   // 宝马汽车子类
	   var BMW =function(){
	   			this.price=price;
	   			this.speed=speed;
	   };
	    vehicleFactory(BMW,'car');
	    BMW.prototype.getPrice=function(){
	    	return this.price;
	    };
	     BMW.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 兰博基尼 汽车子类
	    var lamborghini=function(price,speed){
	    	this.price=price;
	    	this.speed=speed;
	    };
	    vehicleFactory(lamborghini,'car');

	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 宇通汽车子类 
	    var YUTONG=function(price,passenger){
	    	this.price=price;
	    	this.passenger=passenger;
	    };
	    vehicleFactory(YUTONG,'bus');
	   
	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getPassengerNum=function(){
	    	return this.passenger;
	    };
	    var  car = new lamborghini(100000,100);
	    console.log(car.getPrice())

```
 
 ## 建造者模式 （分即是合 ）（四）
 
 + 将一个复杂对象的构建层与表示层相互分离，同样的构建过程可以采用不同的表示
 
 + 创建者更多的是关注创建的细节，不是像其他的工厂模式关注的是结果
 
 + 创建者模式创建的对象是一个复合的对象
 ```js 
 var human=function(param){
 	this.skill=param&&param.skill||'保密';
 	this.hobby=param&&param.hobby||'保密';
 };
 //类人的方法
 human.prototype={
 	getSkill:function(){
 		return this.skill;
 	},
 	getHobby:function(){
 		return this.hobby;
 	}
 };
 var named=function(name){
 	var that=this;
 	(function(name,that){
 		that.wholeName=name;
 		console.log(name.indexOf(' '))// note  这里空格要打开
 		if(name.indexOf('')>-1){
 			that.fristName=name.slice(0,name.indexOf(' '));
 			that.secondName=name.slice(name.indexOf(' '));
 		}
 	})(name,that);
 };
 var work =function(work){
 	var that=this;
 	(function(work,that){
 		switch(work){
 			case 'code':
 			that.work='工程';
 			that.workDesctipt='每天沉醉于编程'
 			break;
 			case 'ui':
 			that.work='设计师';
 			that.workDesctipt='设计更是 一种艺术';
 			break;
 			case 'teach':
 			that.work='教师';
 			that.workDesctipt='分享是一种快乐';
 			break
 			default:
 			that.work='对不起，我们还不清楚您所选择的职位相关描述'
 		}

 	})(work,that)
 };
 work.prototype.changeWork=function(work){
 	this.work=work;
 };
 work.prototype.changeDescript=function(setence){
 	this.workDesctipt=setence
 };
  // 通过对这3类组合调用 就可以创建一个完整的应聘者 
  var person =function(name,worke){
  	var _person=new human();
  	_person.name= new named(name);
  	_person.work=new work(worke);
  	return _person ;
  };
   var personObj= new person('cao hefei','code');
   console.log(personObj)
 ```
 
 ## 原型模式 语言之魂 （五）
 
 + 用原型的实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性及方法
 
 + JavaScript 基于原型链实现对象之间的继承，这种继承是基于一种对属性或者方法的共享，而不是对属性和方法的复制
 
 +  call或者apply 方式是复制继承性能消耗很大
 + 原型模式就是将可以复用的、可共享的、耗时大的从基类提出来然后放在原型中，然后子类通过组合继承或者寄生组合式而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写，这样子类创建的对象既有子类的属性和方法也共享了基类的原型方法
 
 ```js 
 // 原型模式
// 创建一个轮播类 基类共享 call 方式是复制继承性能消耗的大点

 var  loopImages=function(imgArr,container){
 	this.imagesArray=imgArr;
 	this.container=container;

 }

loopImages.prototype={
	constructor :loopImages,
	createImage:function(){
		console.log('loopImages createImage function')
	},
	changeImage:function(){
		console.log('loopImages changeImage function')
	}
};
var slideLoopImg=function(imgArr,container){
	// 构造函数继承图片轮播类’
	loopImages.call(this,imgArr,container);
	slideLoopImg.prototype=new loopImages(); // 这里性能有浪费后期修改
};
slideLoopImg.prototype.changeImage=function(){
	console.log('slideLoopImg changeImage function ')
};
var  fedeLoodImg=function(imgArr ,container, arrow ){
	loopImages.call(this,imgArr,container);
	this.arrow=arrow;
};
fedeLoodImg.prototype=new loopImages();
fedeLoodImg.prototype.changeImage=function(){
	console.log('fadeLoopImgChangeImage function ')
};
// 测试用例 
var fadeimg= new slideLoopImg(['img1','img2'],'#caohefei')
console.log(fadeimg.changeImage())
 ```
 # 结构型模式
 
 
##  代理模式 （一）
+ 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问 
+ 保护代理用于控制不同权限的对象对目标对象的访问 ，但是在JavaScript 中不容易实现保护代理，因为我们无法判断谁访问了某对象 
+ 虚拟代理 是常见的一种代理   根据实际情况来执行某额外的开销叫虚拟代理 

虚拟代理实现图片预加载 

```js 
 var  myImage=(function(){
 	var imgNode= document.createElement('img');
 	document.body.appendChild(imgNode);
 	return {
 		setSrc:function(src){
 			imgNode.src=src
 		}
 	}
 })();
 var proxyImage =(function(){
 	var img =new Image;
 	img.onload=function(){
 		myImage.setSrc(this.src)
 	};
 	return {
 		setSrc:function(src){
 			myImage.setSrc('file:\\E:\\曹合飞\\word\\纪念过去\\IMG_0745.JPG');
 			img.src=src;
 		}
 	};
 })();
 proxyImage.setSrc('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1518258970137&di=771c61665097bdc96ab058a40adafb0f&imgtype=0&src=http%3A%2F%2Ff.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F503d269759ee3d6db032f61b48166d224e4ade6e.jpg');
 
 // 这里代理控制用户对myImage 的访问，并且在此过程中加入一些额外的操作比如真正的图片加载好之前，先把img节点的src 设置一张本地的loading 图片
 
 proxySyncHronousFile 收集一段时间内的请求最后一次性的发给服务器 
 
 var synchonousFile=function(id){
  	console.log('开始同步文件id为：'+id);
  };
  var proxysynchronousFile=(function(){ // 收集两秒的id 发送给服务器 
  	var cache=[],timer;
  	 return function(id ){
  	 	ceche.push(id);
  	 	if(timer){ 
  	 		return // 不会覆盖已经启动的定时器
  	 	};
  	 	timer=setTimeout(function(){
  	 		synchonousFile(cache);
  	 		clearTimeout(timer);
  	 		timer=null;
  	 		cache.length=0 // 清空id 集合 
  	 	},2000)

  	 }
  })();

```
## 适配器模式 （二）
+ 解决两个软件实体间的接口问题不兼容问题。 使用适配器模式之后，原本由于接口不兼容而不能工作的的两个软件实体 可以一起工作。
+ 适配器的别名是包装器是一个相对简单的模式。本书提及的设计模式跟适配器模式结构非常相似，比如装饰者模式，代理模式和外观模式这几种模式都属于*包装模式*
+ 都是由一个对象来包装另外一个对象

```js

var  getGuangDongCity=function(){
	var gungdongcity=[
	{
		name:'shenzheng',
		id:11	
	},{
		name:'guangzhou',
		id:12	
	}
	]
	 return gungdongcity
};
 var  render=function(fn){
 	console.log('开始渲染广东省地图');
 	document.write(JSON.stringify(fn()))
 };
  // render (getGuangDongCity);
  var guangdongcity={
  	shengzheng:11,
  	guangzhou:12,
  	zhuhai:13
  }

 var addressAdapter=function(oldAddressfn){
		 	var address={},
		 	oldAddress=oldAddressfn()
		 	for(var i =0,c;c=oldAddress[i++];){
		 		address[c.name]=c.id;
		 	};
		 	return function(){
		 		 return address;
		 		};
	 };

 render(addressAdapter(getGuangDongCity))
```



## 装饰器模式 （三）
+ 装饰着模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他的对象
+ 装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责，跟继承相比装饰者模式是一种更轻便灵活的做法 **即用即付**
+ 传统的面向对象语言中装饰者模式在JavaScript 中使用的场景并不多，因为 对象并不太介意改动对象自身 
+ 从结构上看装饰着模式更像是包装类型 装饰者模式将一个对象嵌入另一个对象中，实际上相当于这个对象被另外一个对象包装起来，形成一条包装链条。
+ 经典的 使用时ajax 的token 值添加 。

```js
var obj={
name:'caohefei',
address:'张家口'
}
obj.address= obj.address+'蔚县' // javascript 并不关心关心原来的属性改变 

// 简单的 装饰者
 var plane=function(){};
   plane.prototype.fire=function(){
   	console.log('发射普通子弹');
   };
   // 添加两个装饰类 
   var missileDecorator=function(plane){
   	this.plane=plane;
   };
   missileDecorator.prototype.fire=function(){
   	 this.plane.fire();
   	 console.log('发射导弹');
   };
    var  atomdecorator =function(plane){
    	this.plane=plane;
    };
    atomdecorator.prototype.fire=function(){
    	this.plane.fire();
    	console.log('发射原子弹');
    };
    var plane=new plane();
     plane= new missileDecorator(plane);
     plane= new  atomdecorator(plane);
     plane.fire();  // 普通子弹 发射导弹 发射原子弹
     
```
 **Aop装饰函数**  
 + 在实际开发中
 
 ```js 
  // 该方法有点污染原型函数
   例子 一
 Function.prototype.before=function(beforeFn){
    	 var  _self=this;
    	 return function(){   // 返回包含了原函数和新函数的代理函数
    	 	beforeFn.apply(this,arguments);  // 执行新函数 且保证this 不被劫持 新函数接受的参数
    	 	return _self.apply(this,arguments);// 执行原函数并返回原函数的执行结果
    	 }
    };

    Function.prototype.after=function(afterFn){
    	 var  _self=this;
    	 return function(){   // 返回包含了原函数和新函数的代理函数
    	 	var ret = _self.apply(this,arguments);
    	 	afterFn.apply(this,arguments);
    	 	 return ret 
    	 }
    };
    window.onload=function(){
    	console.log(1)
    };
    window.onload=(window.onload||function(){}).before(function(){
    	console.log(555)
    });
    
    例子 二 
    
     var before=function(fn,beforeFn){
     	 return function(){
     	 	 beforeFn.apply(this,arguments);
     	 	  return fn.apply(this,arguments)
     	 };
     };
      var  a=before(function(){ console.log(3)},function(){console.log(2)});
      a= before(a,function(){console.log(1)});
      a() // 1 2 3
      
      
      例子三 
       Function.prototype.after=function(afterFn){
    	 var  _self=this;
    	 return function(){   // 返回包含了原函数和新函数的代理函数
    	 	var ret = _self.apply(this,arguments);
    	 	afterFn.apply(this,arguments);
    	 	 return ret 
    	 }
    };
     var showLogin=function(){
     	console.log('打开登录窗口')；
     };
     var log = function(){
     	console.log('上报服务器')
     };
      showLogin=showLogin.after(log);

      document.getElementById('btn').onclick=showLogin;
   
 ```
 ## 外观模式 （四）
 +  外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义一个新接口；
 + 为一组子系统提供一个简单便利的访问入口 
 + 隔离客户与子系统之间的联系。客户不用去了解子系统的细节
 +  可以跳过 外观模式 直接访问子命令 ，洗衣机 一键功能
 ```js
 var A= function(){
  a1();
  a2();
 };
 var B=function(){
 	 b1();
	 b2();
 };
 var facade=function(){
  A();
  B();
 }
 ```
 ## 组合模式 （伍）
 + 组合模式好处一： 将对象组合成树状结构，以表示 *部分—— 整体*的层次结构。
 + 好处二：通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性
 + 组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是更小的孙对象构建的
 + 组合模式不是父子关系， 组合模式是一种聚合的关系而不是is-a,组合对象包含一组叶对象。但leaf并不是composite 的子类，组合对象请求委托给它所包含的所有叶对象，他们能够合作的关键是拥有相同的接口。
 + 一组叶对象的操作必须具有一致性。
 + 使用情况：1表示对象的部分-整体层次结构，组合模式可以方便的构造一棵树表示对象的部分-整体结构,客户希望统一对待树中的所有对象,组合模式使客户可以忽略组合对象和爷对象的区别,客户子在面对这棵树的时候，不用关心当前正在处理的对象是组合模式还是叶对象。
 ```js 
  var colseDoorCommand={
     	execute:function(){
     		console.log('关门');
     	}
     };
      var openPcCommand={
     	execute:function(){
     		console.log('开电脑');
     	}
     };
      var openQQCommand={
     	execute:function(){
     		console.log('登录QQ');
     	}
     };
       var macroCommand=function(){
       	return {
       		commandList:[],
       		add:function(command){
       			this.commandList.push(command)
       		},
       		execute:function(){
       			for(var i=0,command;command=this.commandList[i++];){
       			command.execute();
       			};
       		}
       		};
       };
       var macroCommand=macroCommand();
       macroCommand.add(colseDoorCommand);
       macroCommand.add(openQQCommand);
       macroCommand.add(openPcCommand);
       macroCommand.execute();
       // 组合模式 扫描文件夹 
       var folder=function(name){
       	this.name=name;
       	this.files=[];
       };
       folder.prototype.add=function(file){
       	this.files.push(file);
       };
       folder.prototype.scan=function(){
       	console.log('扫描文件夹'+this.name);
       	for(var i=0,file,files=this.files;file=files[i++];){
       		file.scan();
       	};
       };
       var file=function(name){
       	this.name=name;
       };
       file.prototype.add=function(){
       	throw new Error('文件下面不能再添加文件');
       };
       file.prototype.scan=function(){
       	console.log('开始扫描文件：'+this.name)
       };
       var  folder0=new folder('学习资料');
       var folder1= new folder('javascript');
       var folder2= new folder('jquery');
       var file1= new file('javascript设计模式23种');
       var file2= new  file('精通jquery');
       var file3= new  file('javascript 算法');
       folder1.add(file1);
       folder2.add(file2);
       folder0.add(file3);
       folder0.add(folder1);
       folder0.add(folder2);
       var folder3= new folder('node.js');
       file4=new file('node深入浅出');
       folder3.add(file4);
       var file5= new file('javascript 语言精髓与编程实践');
       folder0.add(folder3);
       folder0.add(file5);
       folder0.scan();

 ```
 ## 桥接模式
  + 在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。
  + 将公用的代码提取出来解耦，将实现层（如元素绑定的事件）与抽象层（如装饰页面ui逻辑）解耦分离；两部分可以独立变化。
  
 ```js
 //运动单元
  function speed(x,y){
  	this.x=x;
  	this.y=y;
  };
  speed.prototype.run=function(){
  	console.log('运动起来');
  };
  // 着色单元
  function color(cl){
  	this.color=cl;
  };
  color.prototype.draw=function(){
  	console.log('绘制色彩')
  };
  // 变形单元
  function shape(sp){
  	this.shape=sp;
  };
  shape.prototype.change=function(){
  	console.log('改变形状');
  };
  // 说话单元
  function speek(wd){
  	this.word=wd;
  };
  speek.prototype.say=function(){
  	console.log('书写字体')
  };
  //创建可以运动和作色的球类
  function Ball(x,y,c){
  	this.speed=new speed(x,y);
  	this.color= new color(c);
  };
  Ball.prototype.init=function(){
  	this.speed.run();
  	this.color.draw();
  };
  function people(x,y,f){
  	this.speed=new speed(x,y);
  	this.font=new speek(f)
  };
  people.prototype.init=function(){
  	this.speed.run();
  	this.font.say();
  };
  function sprite(x,y,c,s){
  	this.speed=new speed(x,y);
  	this.color=new color(c);
  	this.shape=new shape(s);

  };
  sprite.prototype.init=function(){
  	this.speed.run();
  	this.color.draw();
  	this.shape.change();
  };
  var p = new people(10,12,16);
  p.init();

 ```
 ## 享元模式

  + 享元模式主要还是对其数据，方法共享分离，它将数据和方法分成内部数据和内部方法，外部方法和外部数据
  + 内部数据和内部方法指的是相似或者共有的数据和方法。
  + 外部数据和外部方法指的是不能共用的方法，对象的差异数据 
  
  
  ```js

var arricle=[1,2,3,4,5,6,7,8,9,10,11,12]
var flyWeigth=function(){
	var created=[];
	function create(){
		var dom=document.createElement('div');
		document.getElementById('container').appendChild(dom);
		created.push(dom);
		return dom
	};
	return {
		 getDiv:function(){
		 	if(created.length<5){
		 		return create();
		 	}else{
		 		var div=created.shift();
		 		created.push(div);
		 		return div;
		 	}
		 }
	}
}();
 var paper=0,num=5,len=arricle.length;
 for(var i=0;i<5;i++){
 	if(arricle[i]){
 		flyWeigth.getDiv().innerHTML=arricle[i];
 	};
 };
 document.getElementById('btn').onclick=function(){
 	if(arricle.length<5)return;
 	var n=++paper*num%len
 	j=0
 	for(;j<5;j++){
 		if(arricle[n+j]){
 			flyWeigth.getDiv().innerHTML=arricle[n+j];

 		}else if(arricle[n+j-len]){
 			flyWeigth.getDiv().innerHTML=arricle[n+j-len];

 		}else{
 			flyWeigth.getDiv().innerHTML='';
 		}
 	}
 }
 // 文件上传 使用享元模式
 
 
 var upLoad=function  (upLoadType) {
 	this.upLoadType=upLoadType;
 };
 upLoad.prototype.delFile=function(id){
 	upLoadManager.setExternalState(id,this);
 	if(this.fileSize<3000){
 		return this.dom.parentNode.removeChild(this.dom);
 	};
 	if(window.confirm('确定要删除文件吗'+this.fileName)){
 		return this.dom.parentNode.removeChild(this.dom);
 	};

 };
 var upLoadFactory=(function(){
 	var createdFlyWeightObjs={};
 	return {
 		create:function(upLoadType){
 			if(createdFlyWeightObjs[upLoadType]){
 				return createdFlyWeightObjs[upLoadType];
 			};
 			return createdFlyWeightObjs[upLoadType]= new upLoad(upLoadType);
 		}
 	}
 })(); //  创建 一个上传工厂 
 var  upLoadManager=(function(){
 	var upLoadDatabase={};
 	return {
 		add:function(id,upLoadType,fileName,fileSize){
 			var flyWeightObj=upLoadFactory.create(upLoadType);
 			var dom=document.createElement('div');
 			dom.innerHTML='<span>文件名称:'+fileName+',文件大小:'+fileSize+'</span>'+'<button class="delFile">删除</button>';
 			dom.querySelector('.delFile').onclick=function(){
 				flyWeightObj.delFile(id);
 			};
 			document.body.appendChild(dom);
 			upLoadDatabase[id]={
 				fileName:fileName,
 				fileSize:fileSize,
 				dom:dom
 			};
 			return flyWeightObj 	
 		},
 		setExternalState:function(id,flyWeigthObj){
 			 var upLoadDate=upLoadDatabase[id];
 			 for(var i in upLoadDate){
 			 	flyWeigthObj[i]=upLoadDate[i];
 			 };
 		}
 	}
 })();
 var id=0;
  window.startUpload=function(upLoadType,files){
  	for(var i= 0,file;file=files[i++];){
  		var upLoadObj=upLoadManager.add(++id,upLoadType,file.fileName,file.fileSize)
  	};

  };

  startUpload('plugin',[
  {
  	fileName:'1.txt',
  	fileSize:'8000'
  },
   {
  	fileName:'2.txt',
  	fileSize:'1000'
  },
   {
  	fileName:'3.txt',
  	fileSize:'7000'
  },
   {
  	fileName:'4.txt',
  	fileSize:'4000'
  },
   {
  	fileName:'5.txt',
  	fileSize:'5000'
  }
  ])；
  Java 中的对象池 
  
 
 
 

  ```

 




 
 
 
 
 
 
 
 
 
 
 
 
 
 # 行为型模式 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
