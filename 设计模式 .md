


## 面向对象

+ 面向对象编程以数据为核心，所以在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。

+ 面向对象虽然开发效率高但是代码的运行效率比起面向过程要低很多，这也限制了面向对象的使用场景不能包括那些对性能要求很苛刻的地方。

设计模式(23)

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。



 ## 单例模式
 
 > 核心是：保证一个类仅有一个实例，并提供一个访问它的全局访问点
 >> 单例是一个常见的模式，一些对象我们往往只需要一个，比如线程池 全局缓存 浏览器中的window 对象
 
 
 ### 单例实例
 ```js
      var singLeton=function(name){
      this.name=name;
      this.instance=null;
     };
     singLeton.prototype.getName=function(){
      alter(this.name);
     };
     singLeton.getInstance=function(name){
      if (!this.instance) {
       this.instance=new singLeton(name)
      };
      return this.instance;

     };
     var a=singLeton.getInstance('sven1');
     var b=singLeton.getInstance('sven2');
     console.log(a==b)// true
 ```
 ### 透明的单例模式
 用户从这类中创建对象的时候，可以像使用其他任何普通类一样
 
 ``` js 
 var  creatDiv=(function(){
            var instance ;
            var creatDiv=function(html){
             if(instance){
              return instance
             };
             this.init();
             return instance=this;
            }
            creatDiv.prototype.init=function(){
                   var  div=document.createElement('div');
                   div.innerHTML=this.html;
                   document.body.appendChild(div);
                  }
             return creatDiv
  })();
  var  a= new creatDiv('sven1');
  var  b= new creatDiv('sven2');
  console.log(a===b) //true 
 ```
 ### 缓存代理的应用
 
 ```JS
            var createDiv=function(html){
            this.html=html;
            this.init();
           };
           createDiv.prototype.init=function(){
            var  div=document.createElement('div');
              div.innerHTML=this.html;
              document.body.appendChild(div);
             } ;
            proxySingDiv=(function(){
             var instance
              return function(html){
               if(!instance){
                instance=new  createDiv(html)
               }
               return instance
              }
            })();
            var a= new proxySingDiv('save1');
            var b= new proxySingDiv('save2');
           console.log(a===b)
 ```
 
 ### 通用的惰性单例 **（特别重要）**
 
```js 
var  getSingle=function(fn){
		   	var result;
		   	 return function(){
		   	 	 return result||(result=fn.apply(this,arguments));
		   	 };
   		};
var  createLoginLayer=function(){
		   	 var div =document.createElement('div');
		   	 div.innerHTML='我是登录窗';
		   	 div.style.display='none';
		   	 document.body.appendChild(div);
		   	  return div 
		   };
		   
var createSingleLoginLayer=getSingle(createLoginLayer);	// 创建登录的单例模式

var btn= document.getElementById('btn');
btn.onclick=function(){
 var loginLayer=createSingleLoginLayer();
     	 loginLayer.style.display='block'
};



```

 ## 工厂方法模式
 
 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例
 
 ### 安全的工厂模式及明信片工厂
 ```js 
  var factory=function(type,content){

	    	if(this instanceof factory){
	    		var  s= new this[type](content);
	    		return s
	    	}else{
	    		return  new factory(type,content);
	    	};
	    };
	    factory.prototype={
	    	
	    	constructor:factory,//  注意点 将原型的constructor 指会。
	    	java:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	php:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	javascript:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	}
	    };

       factory('java','i am java')
 new  factory('javascript','i am php')；
 
 ```
 ## 抽象工厂模式 
 + 通过对类的工厂抽象使其业务用于对产品类的创建，而不负责创建某一类产品的实例，及抽象工厂是常见子类的
 
 + **抽象类是一种申明但不能使用的类** 当你使用时就会报错  JavaScript 是灵活的，所以我们可以在类的方法中手动的抛出错误来模拟抽象类
 
 + JavaScript 中abstract 还是一个保留字 所以还不能像面向对象语言那样轻松的创建 
 
 + 抽象类的作用定义一个产品簇，并生声明一些必备的方法 如果子类中没有去重写就会抛出错误
 
 + 通过抽象工厂 我们就知道每个子类到底是哪一种类别，然后他们也具备了该类所必备的属性和方法

```js 
// 抽象工厂方法 
	    var  vehicleFactory=function(subType,superType){
	    	// 判断抽象工厂中是否有该抽象类
	    	if(typeof vehicleFactory[superType]==='function'){
	    		function F(){};
	    		F.prototype = new vehicleFactory[superType](); // 继承父类属性和方法 
	    		subType.prototype=new F();
	    		subType.constructor=subType; // 将子类的constructor 指向子类 
	    	}else{
	    		throw new Error('未创建该抽象类');
	    	};
	    };

	   // 小汽车的抽象类 
	   vehicleFactory.car=function(){
	   	this.type='car';
	   };
	   vehicleFactory.car.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getspeed:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	// 公交车的抽象类
	    vehicleFactory.bus=function(){
	   	this.type='bus';
	   };
	   vehicleFactory.bus.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getPassengerNum:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	   // 宝马汽车子类
	   var BMW =function(){
	   			this.price=price;
	   			this.speed=speed;
	   };
	    vehicleFactory(BMW,'car');
	    BMW.prototype.getPrice=function(){
	    	return this.price;
	    };
	     BMW.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 兰博基尼 汽车子类
	    var lamborghini=function(price,speed){
	    	this.price=price;
	    	this.speed=speed;
	    };
	    vehicleFactory(lamborghini,'car');

	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 宇通汽车子类 
	    var YUTONG=function(price,passenger){
	    	this.price=price;
	    	this.passenger=passenger;
	    };
	    vehicleFactory(YUTONG,'bus');
	   
	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getPassengerNum=function(){
	    	return this.passenger;
	    };
	    var  car = new lamborghini(100000,100);
	    console.log(car.getPrice())

```
 
 ## 建造者模式 （分即是合 ）
 
 + 将一个复杂对象的构建层与表示层相互分离，同样的构建过程可以采用不同的表示
 
 + 创建者更多的是关注创建的细节，不是像其他的工厂模式关注的是结果
 
 + 创建者模式创建的对象是一个复合的对象
 ```js 
 var human=function(param){
 	this.skill=param&&param.skill||'保密';
 	this.hobby=param&&param.hobby||'保密';
 };
 //类人的方法
 human.prototype={
 	getSkill:function(){
 		return this.skill;
 	},
 	getHobby:function(){
 		return this.hobby;
 	}
 };
 var named=function(name){
 	var that=this;
 	(function(name,that){
 		that.wholeName=name;
 		console.log(name.indexOf(' '))// note  这里空格要打开
 		if(name.indexOf('')>-1){
 			that.fristName=name.slice(0,name.indexOf(' '));
 			that.secondName=name.slice(name.indexOf(' '));
 		}
 	})(name,that);
 };
 var work =function(work){
 	var that=this;
 	(function(work,that){
 		switch(work){
 			case 'code':
 			that.work='工程';
 			that.workDesctipt='每天沉醉于编程'
 			break;
 			case 'ui':
 			that.work='设计师';
 			that.workDesctipt='设计更是 一种艺术';
 			break;
 			case 'teach':
 			that.work='教师';
 			that.workDesctipt='分享是一种快乐';
 			break
 			default:
 			that.work='对不起，我们还不清楚您所选择的职位相关描述'
 		}

 	})(work,that)
 };
 work.prototype.changeWork=function(work){
 	this.work=work;
 };
 work.prototype.changeDescript=function(setence){
 	this.workDesctipt=setence
 };
  // 通过对这3类组合调用 就可以创建一个完整的应聘者 
  var person =function(name,worke){
  	var _person=new human();
  	_person.name= new named(name);
  	_person.work=new work(worke);
  	return _person ;
  };
   var personObj= new person('cao hefei','code');
   console.log(personObj)
 ```
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
