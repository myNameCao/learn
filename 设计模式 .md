


## 面向对象

+ 面向对象编程以数据为核心，所以在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。

+ 面向对象虽然开发效率高但是代码的运行效率比起面向过程要低很多，这也限制了面向对象的使用场景不能包括那些对性能要求很苛刻的地方。

设计模式(23)

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


 # 创建型模式
 
 ## 单例模式 （一）
 
 > 核心是：保证一个类仅有一个实例，并提供一个访问它的全局访问点
 >> 单例是一个常见的模式，一些对象我们往往只需要一个，比如线程池 全局缓存 浏览器中的window 对象
 
 
 ### 单例实例
 ```js
      var singLeton=function(name){
      this.name=name;
      this.instance=null;
     };
     singLeton.prototype.getName=function(){
      alter(this.name);
     };
     singLeton.getInstance=function(name){
      if (!this.instance) {
       this.instance=new singLeton(name)
      };
      return this.instance;

     };
     var a=singLeton.getInstance('sven1');
     var b=singLeton.getInstance('sven2');
     console.log(a==b)// true
 ```
 ### 透明的单例模式
 用户从这类中创建对象的时候，可以像使用其他任何普通类一样
 
 ``` js 
 var  creatDiv=(function(){
            var instance ;
            var creatDiv=function(html){
             if(instance){
              return instance
             };
             this.init();
             return instance=this;
            }
            creatDiv.prototype.init=function(){
                   var  div=document.createElement('div');
                   div.innerHTML=this.html;
                   document.body.appendChild(div);
                  }
             return creatDiv
  })();
  var  a= new creatDiv('sven1');
  var  b= new creatDiv('sven2');
  console.log(a===b) //true 
 ```
 ### 缓存代理的应用
 
 ```JS
            var createDiv=function(html){
            this.html=html;
            this.init();
           };
           createDiv.prototype.init=function(){
            var  div=document.createElement('div');
              div.innerHTML=this.html;
              document.body.appendChild(div);
             } ;
            proxySingDiv=(function(){
             var instance
              return function(html){
               if(!instance){
                instance=new  createDiv(html)
               }
               return instance
              }
            })();
            var a= new proxySingDiv('save1');
            var b= new proxySingDiv('save2');
           console.log(a===b)
 ```
 
 ### 通用的惰性单例 **（特别重要）**
 
```js 
var  getSingle=function(fn){
		   	var result;
		   	 return function(){
		   	 	 return result||(result=fn.apply(this,arguments));
		   	 };
   		};
var  createLoginLayer=function(){
		   	 var div =document.createElement('div');
		   	 div.innerHTML='我是登录窗';
		   	 div.style.display='none';
		   	 document.body.appendChild(div);
		   	  return div 
		   };
		   
var createSingleLoginLayer=getSingle(createLoginLayer);	// 创建登录的单例模式

var btn= document.getElementById('btn');
btn.onclick=function(){
 var loginLayer=createSingleLoginLayer();
     	 loginLayer.style.display='block'
};



```

 ## 工厂方法模式（二）
 
 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例
 
 ### 安全的工厂模式及明信片工厂
 ```js 
  var factory=function(type,content){

	    	if(this instanceof factory){
	    		var  s= new this[type](content);
	    		return s
	    	}else{
	    		return  new factory(type,content);
	    	};
	    };
	    factory.prototype={
	    	
	    	constructor:factory,//  注意点 将原型的constructor 指会。
	    	java:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	php:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	javascript:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	}
	    };

       factory('java','i am java')
 new  factory('javascript','i am php')；
 
 ```
 ## 抽象工厂模式 （三）
 + 通过对类的工厂抽象使其业务用于对产品类的创建，而不负责创建某一类产品的实例，及抽象工厂是常见子类的
 
 + **抽象类是一种申明但不能使用的类** 当你使用时就会报错  JavaScript 是灵活的，所以我们可以在类的方法中手动的抛出错误来模拟抽象类
 
 + JavaScript 中abstract 还是一个保留字 所以还不能像面向对象语言那样轻松的创建 
 
 + 抽象类的作用定义一个产品簇，并生声明一些必备的方法 如果子类中没有去重写就会抛出错误
 
 + 通过抽象工厂 我们就知道每个子类到底是哪一种类别，然后他们也具备了该类所必备的属性和方法

```js 
// 抽象工厂方法 
	    var  vehicleFactory=function(subType,superType){
	    	// 判断抽象工厂中是否有该抽象类
	    	if(typeof vehicleFactory[superType]==='function'){
	    		function F(){};
	    		F.prototype = new vehicleFactory[superType](); // 继承父类属性和方法 
	    		subType.prototype=new F();
	    		subType.constructor=subType; // 将子类的constructor 指向子类 
	    	}else{
	    		throw new Error('未创建该抽象类');
	    	};
	    };

	   // 小汽车的抽象类 
	   vehicleFactory.car=function(){
	   	this.type='car';
	   };
	   vehicleFactory.car.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getspeed:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	// 公交车的抽象类
	    vehicleFactory.bus=function(){
	   	this.type='bus';
	   };
	   vehicleFactory.bus.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getPassengerNum:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	   // 宝马汽车子类
	   var BMW =function(){
	   			this.price=price;
	   			this.speed=speed;
	   };
	    vehicleFactory(BMW,'car');
	    BMW.prototype.getPrice=function(){
	    	return this.price;
	    };
	     BMW.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 兰博基尼 汽车子类
	    var lamborghini=function(price,speed){
	    	this.price=price;
	    	this.speed=speed;
	    };
	    vehicleFactory(lamborghini,'car');

	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 宇通汽车子类 
	    var YUTONG=function(price,passenger){
	    	this.price=price;
	    	this.passenger=passenger;
	    };
	    vehicleFactory(YUTONG,'bus');
	   
	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getPassengerNum=function(){
	    	return this.passenger;
	    };
	    var  car = new lamborghini(100000,100);
	    console.log(car.getPrice())

```
 
 ## 建造者模式 （分即是合 ）（四）
 
 + 将一个复杂对象的构建层与表示层相互分离，同样的构建过程可以采用不同的表示
 
 + 创建者更多的是关注创建的细节，不是像其他的工厂模式关注的是结果
 
 + 创建者模式创建的对象是一个复合的对象
 ```js 
 var human=function(param){
 	this.skill=param&&param.skill||'保密';
 	this.hobby=param&&param.hobby||'保密';
 };
 //类人的方法
 human.prototype={
 	getSkill:function(){
 		return this.skill;
 	},
 	getHobby:function(){
 		return this.hobby;
 	}
 };
 var named=function(name){
 	var that=this;
 	(function(name,that){
 		that.wholeName=name;
 		console.log(name.indexOf(' '))// note  这里空格要打开
 		if(name.indexOf('')>-1){
 			that.fristName=name.slice(0,name.indexOf(' '));
 			that.secondName=name.slice(name.indexOf(' '));
 		}
 	})(name,that);
 };
 var work =function(work){
 	var that=this;
 	(function(work,that){
 		switch(work){
 			case 'code':
 			that.work='工程';
 			that.workDesctipt='每天沉醉于编程'
 			break;
 			case 'ui':
 			that.work='设计师';
 			that.workDesctipt='设计更是 一种艺术';
 			break;
 			case 'teach':
 			that.work='教师';
 			that.workDesctipt='分享是一种快乐';
 			break
 			default:
 			that.work='对不起，我们还不清楚您所选择的职位相关描述'
 		}

 	})(work,that)
 };
 work.prototype.changeWork=function(work){
 	this.work=work;
 };
 work.prototype.changeDescript=function(setence){
 	this.workDesctipt=setence
 };
  // 通过对这3类组合调用 就可以创建一个完整的应聘者 
  var person =function(name,worke){
  	var _person=new human();
  	_person.name= new named(name);
  	_person.work=new work(worke);
  	return _person ;
  };
   var personObj= new person('cao hefei','code');
   console.log(personObj)
 ```
 
 ## 原型模式 语言之魂 （五）
 
 + 用原型的实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性及方法
 
 + JavaScript 基于原型链实现对象之间的继承，这种继承是基于一种对属性或者方法的共享，而不是对属性和方法的复制
 
 +  call或者apply 方式是复制继承性能消耗很大
 + 原型模式就是将可以复用的、可共享的、耗时大的从基类提出来然后放在原型中，然后子类通过组合继承或者寄生组合式而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写，这样子类创建的对象既有子类的属性和方法也共享了基类的原型方法
 
 ```js 
 // 原型模式
// 创建一个轮播类 基类共享 call 方式是复制继承性能消耗的大点

 var  loopImages=function(imgArr,container){
 	this.imagesArray=imgArr;
 	this.container=container;

 }

loopImages.prototype={
	constructor :loopImages,
	createImage:function(){
		console.log('loopImages createImage function')
	},
	changeImage:function(){
		console.log('loopImages changeImage function')
	}
};
var slideLoopImg=function(imgArr,container){
	// 构造函数继承图片轮播类’
	loopImages.call(this,imgArr,container);
	slideLoopImg.prototype=new loopImages(); // 这里性能有浪费后期修改
};
slideLoopImg.prototype.changeImage=function(){
	console.log('slideLoopImg changeImage function ')
};
var  fedeLoodImg=function(imgArr ,container, arrow ){
	loopImages.call(this,imgArr,container);
	this.arrow=arrow;
};
fedeLoodImg.prototype=new loopImages();
fedeLoodImg.prototype.changeImage=function(){
	console.log('fadeLoopImgChangeImage function ')
};
// 测试用例 
var fadeimg= new slideLoopImg(['img1','img2'],'#caohefei')
console.log(fadeimg.changeImage())
 ```
 # 结构型模式
 
 
##  代理模式 （一）
+ 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问 
+ 保护代理用于控制不同权限的对象对目标对象的访问 ，但是在JavaScript 中不容易实现保护代理，因为我们无法判断谁访问了某对象 
+ 虚拟代理 是常见的一种代理   根据实际情况来执行某额外的开销叫虚拟代理 

虚拟代理实现图片预加载 

```js 
 var  myImage=(function(){
 	var imgNode= document.createElement('img');
 	document.body.appendChild(imgNode);
 	return {
 		setSrc:function(src){
 			imgNode.src=src
 		}
 	}
 })();
 var proxyImage =(function(){
 	var img =new Image;
 	img.onload=function(){
 		myImage.setSrc(this.src)
 	};
 	return {
 		setSrc:function(src){
 			myImage.setSrc('file:\\E:\\曹合飞\\word\\纪念过去\\IMG_0745.JPG');
 			img.src=src;
 		}
 	};
 })();
 proxyImage.setSrc('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1518258970137&di=771c61665097bdc96ab058a40adafb0f&imgtype=0&src=http%3A%2F%2Ff.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F503d269759ee3d6db032f61b48166d224e4ade6e.jpg');
 
 // 这里代理控制用户对myImage 的访问，并且在此过程中加入一些额外的操作比如真正的图片加载好之前，先把img节点的src 设置一张本地的loading 图片
 
 proxySyncHronousFile 收集一段时间内的请求最后一次性的发给服务器 
 
 var synchonousFile=function(id){
  	console.log('开始同步文件id为：'+id);
  };
  var proxysynchronousFile=(function(){ // 收集两秒的id 发送给服务器 
  	var cache=[],timer;
  	 return function(id ){
  	 	ceche.push(id);
  	 	if(timer){ 
  	 		return // 不会覆盖已经启动的定时器
  	 	};
  	 	timer=setTimeout(function(){
  	 		synchonousFile(cache);
  	 		clearTimeout(timer);
  	 		timer=null;
  	 		cache.length=0 // 清空id 集合 
  	 	},2000)

  	 }
  })();

```
## 适配器模式 （二）



## 装饰器模式 （三）
+ 装饰着模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他的对象
+ 装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责，跟继承相比装饰者模式是一种更轻便灵活的做法 **即用即付**
+ 传统的面向对象语言中装饰者模式在JavaScript 中使用的场景并不多，因为 对象并不太介意改动对象自身 
```js
var obj={
name:'caohefei',
address:'张家口'
}
obj.address= obj.address+'蔚县' // javascript 并不关心关心原来的属性改变 



```





 
 
 
 
 
 
 
 
 
 
 
 
 
 # 行为型模式 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
