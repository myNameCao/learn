


## 面向对象

+ 面向对象编程以数据为核心，所以在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。

+ 面向对象虽然开发效率高但是代码的运行效率比起面向过程要低很多，这也限制了面向对象的使用场景不能包括那些对性能要求很苛刻的地方。

设计模式(23)

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


 # 创建型模式
 
 ## 单例模式 （一）
 
 > 核心是：保证一个类仅有一个实例，并提供一个访问它的全局访问点
 >> 单例是一个常见的模式，一些对象我们往往只需要一个，比如线程池 全局缓存 浏览器中的window 对象
 
 
 ### 单例实例
 ```js
      var singLeton=function(name){
      this.name=name;
      this.instance=null;
     };
     singLeton.prototype.getName=function(){
      alter(this.name);
     };
     singLeton.getInstance=function(name){
      if (!this.instance) {
       this.instance=new singLeton(name)
      };
      return this.instance;

     };
     var a=singLeton.getInstance('sven1');
     var b=singLeton.getInstance('sven2');
     console.log(a==b)// true
 ```
 ### 透明的单例模式
 用户从这类中创建对象的时候，可以像使用其他任何普通类一样
 
 ``` js 
 var  creatDiv=(function(){
            var instance ;
            var creatDiv=function(html){
             if(instance){
              return instance
             };
             this.init();
             return instance=this;
            }
            creatDiv.prototype.init=function(){
                   var  div=document.createElement('div');
                   div.innerHTML=this.html;
                   document.body.appendChild(div);
                  }
             return creatDiv
  })();
  var  a= new creatDiv('sven1');
  var  b= new creatDiv('sven2');
  console.log(a===b) //true 
 ```
 ### 缓存代理的应用
 
 ```JS
            var createDiv=function(html){
            this.html=html;
            this.init();
           };
           createDiv.prototype.init=function(){
            var  div=document.createElement('div');
              div.innerHTML=this.html;
              document.body.appendChild(div);
             } ;
            proxySingDiv=(function(){
             var instance
              return function(html){
               if(!instance){
                instance=new  createDiv(html)
               }
               return instance
              }
            })();
            var a= new proxySingDiv('save1');
            var b= new proxySingDiv('save2');
           console.log(a===b)
 ```
 
 ### 通用的惰性单例 **（特别重要）**
 
```js 
var  getSingle=function(fn){
		   	var result;
		   	 return function(){
		   	 	 return result||(result=fn.apply(this,arguments));
		   	 };
   		};
var  createLoginLayer=function(){
		   	 var div =document.createElement('div');
		   	 div.innerHTML='我是登录窗';
		   	 div.style.display='none';
		   	 document.body.appendChild(div);
		   	  return div 
		   };
		   
var createSingleLoginLayer=getSingle(createLoginLayer);	// 创建登录的单例模式

var btn= document.getElementById('btn');
btn.onclick=function(){
 var loginLayer=createSingleLoginLayer();
     	 loginLayer.style.display='block'
};



```

 ## 工厂方法模式（二）
 
 通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例
 
 ### 安全的工厂模式及明信片工厂
 ```js 
  var factory=function(type,content){

	    	if(this instanceof factory){
	    		var  s= new this[type](content);
	    		return s
	    	}else{
	    		return  new factory(type,content);
	    	};
	    };
	    factory.prototype={
	    	
	    	constructor:factory,//  注意点 将原型的constructor 指会。
	    	java:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	php:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	},
	    	javascript:function(content){
	    		this.content=content;
	    		(function(content){
	    			var div=document.createElement('div');
	    			div.innerHTML=content;
	    			div.style.border='1px  solid red ';
	    			document.body.appendChild(div)
	    		})(content)
	    	}
	    };

       factory('java','i am java')
 new  factory('javascript','i am php')；
 
 ```
 ## 抽象工厂模式 （三）
 + 通过对类的工厂抽象使其业务用于对产品类的创建，而不负责创建某一类产品的实例，及抽象工厂是常见子类的
 
 + **抽象类是一种申明但不能使用的类** 当你使用时就会报错  JavaScript 是灵活的，所以我们可以在类的方法中手动的抛出错误来模拟抽象类
 
 + JavaScript 中abstract 还是一个保留字 所以还不能像面向对象语言那样轻松的创建 
 
 + 抽象类的作用定义一个产品簇，并生声明一些必备的方法 如果子类中没有去重写就会抛出错误
 
 + 通过抽象工厂 我们就知道每个子类到底是哪一种类别，然后他们也具备了该类所必备的属性和方法

```js 
// 抽象工厂方法 
	    var  vehicleFactory=function(subType,superType){
	    	// 判断抽象工厂中是否有该抽象类
	    	if(typeof vehicleFactory[superType]==='function'){
	    		function F(){};
	    		F.prototype = new vehicleFactory[superType](); // 继承父类属性和方法 
	    		subType.prototype=new F();
	    		subType.constructor=subType; // 将子类的constructor 指向子类 
	    	}else{
	    		throw new Error('未创建该抽象类');
	    	};
	    };

	   // 小汽车的抽象类 
	   vehicleFactory.car=function(){
	   	this.type='car';
	   };
	   vehicleFactory.car.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getspeed:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	// 公交车的抽象类
	    vehicleFactory.bus=function(){
	   	this.type='bus';
	   };
	   vehicleFactory.bus.prototype={
	   	getPrice:function(){
	   		return new Error('抽象方法不能调用')
	   	},
	   	getPassengerNum:function(){
	   		return new Error('抽象方法不能调用')
	   	}
	   };
	   // 宝马汽车子类
	   var BMW =function(){
	   			this.price=price;
	   			this.speed=speed;
	   };
	    vehicleFactory(BMW,'car');
	    BMW.prototype.getPrice=function(){
	    	return this.price;
	    };
	     BMW.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 兰博基尼 汽车子类
	    var lamborghini=function(price,speed){
	    	this.price=price;
	    	this.speed=speed;
	    };
	    vehicleFactory(lamborghini,'car');

	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getspeed=function(){
	    	return this.speed;
	    };
	    // 宇通汽车子类 
	    var YUTONG=function(price,passenger){
	    	this.price=price;
	    	this.passenger=passenger;
	    };
	    vehicleFactory(YUTONG,'bus');
	   
	     lamborghini.prototype.getPrice=function(){
	    	return this.price;
	    };
	     lamborghini.prototype.getPassengerNum=function(){
	    	return this.passenger;
	    };
	    var  car = new lamborghini(100000,100);
	    console.log(car.getPrice())

```
 
 ## 建造者模式 （分即是合 ）（四）
 
 + 将一个复杂对象的构建层与表示层相互分离，同样的构建过程可以采用不同的表示
 
 + 创建者更多的是关注创建的细节，不是像其他的工厂模式关注的是结果
 
 + 创建者模式创建的对象是一个复合的对象
 ```js 
 var human=function(param){
 	this.skill=param&&param.skill||'保密';
 	this.hobby=param&&param.hobby||'保密';
 };
 //类人的方法
 human.prototype={
 	getSkill:function(){
 		return this.skill;
 	},
 	getHobby:function(){
 		return this.hobby;
 	}
 };
 var named=function(name){
 	var that=this;
 	(function(name,that){
 		that.wholeName=name;
 		console.log(name.indexOf(' '))// note  这里空格要打开
 		if(name.indexOf('')>-1){
 			that.fristName=name.slice(0,name.indexOf(' '));
 			that.secondName=name.slice(name.indexOf(' '));
 		}
 	})(name,that);
 };
 var work =function(work){
 	var that=this;
 	(function(work,that){
 		switch(work){
 			case 'code':
 			that.work='工程';
 			that.workDesctipt='每天沉醉于编程'
 			break;
 			case 'ui':
 			that.work='设计师';
 			that.workDesctipt='设计更是 一种艺术';
 			break;
 			case 'teach':
 			that.work='教师';
 			that.workDesctipt='分享是一种快乐';
 			break
 			default:
 			that.work='对不起，我们还不清楚您所选择的职位相关描述'
 		}

 	})(work,that)
 };
 work.prototype.changeWork=function(work){
 	this.work=work;
 };
 work.prototype.changeDescript=function(setence){
 	this.workDesctipt=setence
 };
  // 通过对这3类组合调用 就可以创建一个完整的应聘者 
  var person =function(name,worke){
  	var _person=new human();
  	_person.name= new named(name);
  	_person.work=new work(worke);
  	return _person ;
  };
   var personObj= new person('cao hefei','code');
   console.log(personObj)
 ```
 
 ## 原型模式 语言之魂 （五）
 
 + 用原型的实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性及方法
 
 + JavaScript 基于原型链实现对象之间的继承，这种继承是基于一种对属性或者方法的共享，而不是对属性和方法的复制
 
 +  call或者apply 方式是复制继承性能消耗很大
 + 原型模式就是将可以复用的、可共享的、耗时大的从基类提出来然后放在原型中，然后子类通过组合继承或者寄生组合式而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写，这样子类创建的对象既有子类的属性和方法也共享了基类的原型方法
 
 ```js 
 // 原型模式
// 创建一个轮播类 基类共享 call 方式是复制继承性能消耗的大点

 var  loopImages=function(imgArr,container){
 	this.imagesArray=imgArr;
 	this.container=container;

 }

loopImages.prototype={
	constructor :loopImages,
	createImage:function(){
		console.log('loopImages createImage function')
	},
	changeImage:function(){
		console.log('loopImages changeImage function')
	}
};
var slideLoopImg=function(imgArr,container){
	// 构造函数继承图片轮播类’
	loopImages.call(this,imgArr,container);
	slideLoopImg.prototype=new loopImages(); // 这里性能有浪费后期修改
};
slideLoopImg.prototype.changeImage=function(){
	console.log('slideLoopImg changeImage function ')
};
var  fedeLoodImg=function(imgArr ,container, arrow ){
	loopImages.call(this,imgArr,container);
	this.arrow=arrow;
};
fedeLoodImg.prototype=new loopImages();
fedeLoodImg.prototype.changeImage=function(){
	console.log('fadeLoopImgChangeImage function ')
};
// 测试用例 
var fadeimg= new slideLoopImg(['img1','img2'],'#caohefei')
console.log(fadeimg.changeImage())
 ```
 # 结构型模式
 
 
##  代理模式 （一）
+ 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问 
+ 保护代理用于控制不同权限的对象对目标对象的访问 ，但是在JavaScript 中不容易实现保护代理，因为我们无法判断谁访问了某对象 
+ 虚拟代理 是常见的一种代理   根据实际情况来执行某额外的开销叫虚拟代理 

虚拟代理实现图片预加载 

```js 
 var  myImage=(function(){
 	var imgNode= document.createElement('img');
 	document.body.appendChild(imgNode);
 	return {
 		setSrc:function(src){
 			imgNode.src=src
 		}
 	}
 })();
 var proxyImage =(function(){
 	var img =new Image;
 	img.onload=function(){
 		myImage.setSrc(this.src)
 	};
 	return {
 		setSrc:function(src){
 			myImage.setSrc('file:\\E:\\曹合飞\\word\\纪念过去\\IMG_0745.JPG');
 			img.src=src;
 		}
 	};
 })();
 proxyImage.setSrc('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1518258970137&di=771c61665097bdc96ab058a40adafb0f&imgtype=0&src=http%3A%2F%2Ff.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F503d269759ee3d6db032f61b48166d224e4ade6e.jpg');
 
 // 这里代理控制用户对myImage 的访问，并且在此过程中加入一些额外的操作比如真正的图片加载好之前，先把img节点的src 设置一张本地的loading 图片
 
 proxySyncHronousFile 收集一段时间内的请求最后一次性的发给服务器 
 
 var synchonousFile=function(id){
  	console.log('开始同步文件id为：'+id);
  };
  var proxysynchronousFile=(function(){ // 收集两秒的id 发送给服务器 
  	var cache=[],timer;
  	 return function(id ){
  	 	ceche.push(id);
  	 	if(timer){ 
  	 		return // 不会覆盖已经启动的定时器
  	 	};
  	 	timer=setTimeout(function(){
  	 		synchonousFile(cache);
  	 		clearTimeout(timer);
  	 		timer=null;
  	 		cache.length=0 // 清空id 集合 
  	 	},2000)

  	 }
  })();

```
## 适配器模式 （二）
+ 解决两个软件实体间的接口问题不兼容问题。 使用适配器模式之后，原本由于接口不兼容而不能工作的的两个软件实体 可以一起工作。
+ 适配器的别名是包装器是一个相对简单的模式。本书提及的设计模式跟适配器模式结构非常相似，比如装饰者模式，代理模式和外观模式这几种模式都属于*包装模式*
+ 都是由一个对象来包装另外一个对象

```js

var  getGuangDongCity=function(){
	var gungdongcity=[
	{
		name:'shenzheng',
		id:11	
	},{
		name:'guangzhou',
		id:12	
	}
	]
	 return gungdongcity
};
 var  render=function(fn){
 	console.log('开始渲染广东省地图');
 	document.write(JSON.stringify(fn()))
 };
  // render (getGuangDongCity);
  var guangdongcity={
  	shengzheng:11,
  	guangzhou:12,
  	zhuhai:13
  }

 var addressAdapter=function(oldAddressfn){
		 	var address={},
		 	oldAddress=oldAddressfn()
		 	for(var i =0,c;c=oldAddress[i++];){
		 		address[c.name]=c.id;
		 	};
		 	return function(){
		 		 return address;
		 		};
	 };

 render(addressAdapter(getGuangDongCity))
```



## 装饰器模式 （三）
+ 装饰着模式可以动态地给某个对象添加一些额外的职责，而不会影响从这个类中派生的其他的对象
+ 装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责，跟继承相比装饰者模式是一种更轻便灵活的做法 **即用即付**
+ 传统的面向对象语言中装饰者模式在JavaScript 中使用的场景并不多，因为 对象并不太介意改动对象自身 
+ 从结构上看装饰着模式更像是包装类型 装饰者模式将一个对象嵌入另一个对象中，实际上相当于这个对象被另外一个对象包装起来，形成一条包装链条。
+ 经典的 使用时ajax 的token 值添加 。

```js
var obj={
name:'caohefei',
address:'张家口'
}
obj.address= obj.address+'蔚县' // javascript 并不关心关心原来的属性改变 

// 简单的 装饰者
 var plane=function(){};
   plane.prototype.fire=function(){
   	console.log('发射普通子弹');
   };
   // 添加两个装饰类 
   var missileDecorator=function(plane){
   	this.plane=plane;
   };
   missileDecorator.prototype.fire=function(){
   	 this.plane.fire();
   	 console.log('发射导弹');
   };
    var  atomdecorator =function(plane){
    	this.plane=plane;
    };
    atomdecorator.prototype.fire=function(){
    	this.plane.fire();
    	console.log('发射原子弹');
    };
    var plane=new plane();
     plane= new missileDecorator(plane);
     plane= new  atomdecorator(plane);
     plane.fire();  // 普通子弹 发射导弹 发射原子弹
     
```
 **Aop装饰函数**  
 + 在实际开发中
 
 ```js 
  // 该方法有点污染原型函数
   例子 一
 Function.prototype.before=function(beforeFn){
    	 var  _self=this;
    	 return function(){   // 返回包含了原函数和新函数的代理函数
    	 	beforeFn.apply(this,arguments);  // 执行新函数 且保证this 不被劫持 新函数接受的参数
    	 	return _self.apply(this,arguments);// 执行原函数并返回原函数的执行结果
    	 }
    };

    Function.prototype.after=function(afterFn){
    	 var  _self=this;
    	 return function(){   // 返回包含了原函数和新函数的代理函数
    	 	var ret = _self.apply(this,arguments);
    	 	afterFn.apply(this,arguments);
    	 	 return ret 
    	 }
    };
    window.onload=function(){
    	console.log(1)
    };
    window.onload=(window.onload||function(){}).before(function(){
    	console.log(555)
    });
    
    例子 二 
    
     var before=function(fn,beforeFn){
     	 return function(){
     	 	 beforeFn.apply(this,arguments);
     	 	  return fn.apply(this,arguments)
     	 };
     };
      var  a=before(function(){ console.log(3)},function(){console.log(2)});
      a= before(a,function(){console.log(1)});
      a() // 1 2 3
      
      
      例子三 
       Function.prototype.after=function(afterFn){
    	 var  _self=this;
    	 return function(){   // 返回包含了原函数和新函数的代理函数
    	 	var ret = _self.apply(this,arguments);
    	 	afterFn.apply(this,arguments);
    	 	 return ret 
    	 }
    };
     var showLogin=function(){
     	console.log('打开登录窗口')；
     };
     var log = function(){
     	console.log('上报服务器')
     };
      showLogin=showLogin.after(log);

      document.getElementById('btn').onclick=showLogin;
   
 ```
 ## 外观模式 （四）
 +  外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义一个新接口；
 + 为一组子系统提供一个简单便利的访问入口 
 + 隔离客户与子系统之间的联系。客户不用去了解子系统的细节
 +  可以跳过 外观模式 直接访问子命令 ，洗衣机 一键功能
 ```js
 var A= function(){
  a1();
  a2();
 };
 var B=function(){
 	 b1();
	 b2();
 };
 var facade=function(){
  A();
  B();
 }
 ```
 ## 组合模式 （伍）
 + 组合模式好处一： 将对象组合成树状结构，以表示 *部分—— 整体*的层次结构。
 + 好处二：通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性
 + 组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是更小的孙对象构建的
 + 组合模式不是父子关系， 组合模式是一种聚合的关系而不是is-a,组合对象包含一组叶对象。但leaf并不是composite 的子类，组合对象请求委托给它所包含的所有叶对象，他们能够合作的关键是拥有相同的接口。
 + 一组叶对象的操作必须具有一致性。
 + 使用情况：1表示对象的部分-整体层次结构，组合模式可以方便的构造一棵树表示对象的部分-整体结构,客户希望统一对待树中的所有对象,组合模式使客户可以忽略组合对象和爷对象的区别,客户子在面对这棵树的时候，不用关心当前正在处理的对象是组合模式还是叶对象。
 ```js 
  var colseDoorCommand={
     	execute:function(){
     		console.log('关门');
     	}
     };
      var openPcCommand={
     	execute:function(){
     		console.log('开电脑');
     	}
     };
      var openQQCommand={
     	execute:function(){
     		console.log('登录QQ');
     	}
     };
       var macroCommand=function(){
       	return {
       		commandList:[],
       		add:function(command){
       			this.commandList.push(command)
       		},
       		execute:function(){
       			for(var i=0,command;command=this.commandList[i++];){
       			command.execute();
       			};
       		}
       		};
       };
       var macroCommand=macroCommand();
       macroCommand.add(colseDoorCommand);
       macroCommand.add(openQQCommand);
       macroCommand.add(openPcCommand);
       macroCommand.execute();
       // 组合模式 扫描文件夹 
       var folder=function(name){
       	this.name=name;
       	this.files=[];
       };
       folder.prototype.add=function(file){
       	this.files.push(file);
       };
       folder.prototype.scan=function(){
       	console.log('扫描文件夹'+this.name);
       	for(var i=0,file,files=this.files;file=files[i++];){
       		file.scan();
       	};
       };
       var file=function(name){
       	this.name=name;
       };
       file.prototype.add=function(){
       	throw new Error('文件下面不能再添加文件');
       };
       file.prototype.scan=function(){
       	console.log('开始扫描文件：'+this.name)
       };
       var  folder0=new folder('学习资料');
       var folder1= new folder('javascript');
       var folder2= new folder('jquery');
       var file1= new file('javascript设计模式23种');
       var file2= new  file('精通jquery');
       var file3= new  file('javascript 算法');
       folder1.add(file1);
       folder2.add(file2);
       folder0.add(file3);
       folder0.add(folder1);
       folder0.add(folder2);
       var folder3= new folder('node.js');
       file4=new file('node深入浅出');
       folder3.add(file4);
       var file5= new file('javascript 语言精髓与编程实践');
       folder0.add(folder3);
       folder0.add(file5);
       folder0.scan();

 ```
 ## 桥接模式（六）
  + 在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。
  + 将公用的代码提取出来解耦，将实现层（如元素绑定的事件）与抽象层（如装饰页面ui逻辑）解耦分离；两部分可以独立变化。
  
 ```js
 //运动单元
  function speed(x,y){
  	this.x=x;
  	this.y=y;
  };
  speed.prototype.run=function(){
  	console.log('运动起来');
  };
  // 着色单元
  function color(cl){
  	this.color=cl;
  };
  color.prototype.draw=function(){
  	console.log('绘制色彩')
  };
  // 变形单元
  function shape(sp){
  	this.shape=sp;
  };
  shape.prototype.change=function(){
  	console.log('改变形状');
  };
  // 说话单元
  function speek(wd){
  	this.word=wd;
  };
  speek.prototype.say=function(){
  	console.log('书写字体')
  };
  //创建可以运动和作色的球类
  function Ball(x,y,c){
  	this.speed=new speed(x,y);
  	this.color= new color(c);
  };
  Ball.prototype.init=function(){
  	this.speed.run();
  	this.color.draw();
  };
  function people(x,y,f){
  	this.speed=new speed(x,y);
  	this.font=new speek(f)
  };
  people.prototype.init=function(){
  	this.speed.run();
  	this.font.say();
  };
  function sprite(x,y,c,s){
  	this.speed=new speed(x,y);
  	this.color=new color(c);
  	this.shape=new shape(s);

  };
  sprite.prototype.init=function(){
  	this.speed.run();
  	this.color.draw();
  	this.shape.change();
  };
  var p = new people(10,12,16);
  p.init();

 ```
 ## 享元模式  （七）

  + 享元模式主要还是对其数据，方法共享分离，它将数据和方法分成内部数据和内部方法，外部方法和外部数据
  + 内部数据和内部方法指的是相似或者共有的数据和方法。
  + 外部数据和外部方法指的是不能共用的方法，对象的差异数据 
  
  
  ```js

var arricle=[1,2,3,4,5,6,7,8,9,10,11,12]
var flyWeigth=function(){
	var created=[];
	function create(){
		var dom=document.createElement('div');
		document.getElementById('container').appendChild(dom);
		created.push(dom);
		return dom
	};
	return {
		 getDiv:function(){
		 	if(created.length<5){
		 		return create();
		 	}else{
		 		var div=created.shift();
		 		created.push(div);
		 		return div;
		 	}
		 }
	}
}();
 var paper=0,num=5,len=arricle.length;
 for(var i=0;i<5;i++){
 	if(arricle[i]){
 		flyWeigth.getDiv().innerHTML=arricle[i];
 	};
 };
 document.getElementById('btn').onclick=function(){
 	if(arricle.length<5)return;
 	var n=++paper*num%len
 	j=0
 	for(;j<5;j++){
 		if(arricle[n+j]){
 			flyWeigth.getDiv().innerHTML=arricle[n+j];

 		}else if(arricle[n+j-len]){
 			flyWeigth.getDiv().innerHTML=arricle[n+j-len];

 		}else{
 			flyWeigth.getDiv().innerHTML='';
 		}
 	}
 }
 // 文件上传 使用享元模式
 
 
 var upLoad=function  (upLoadType) {
 	this.upLoadType=upLoadType;
 };
 upLoad.prototype.delFile=function(id){
 	upLoadManager.setExternalState(id,this);
 	if(this.fileSize<3000){
 		return this.dom.parentNode.removeChild(this.dom);
 	};
 	if(window.confirm('确定要删除文件吗'+this.fileName)){
 		return this.dom.parentNode.removeChild(this.dom);
 	};

 };
 var upLoadFactory=(function(){
 	var createdFlyWeightObjs={};
 	return {
 		create:function(upLoadType){
 			if(createdFlyWeightObjs[upLoadType]){
 				return createdFlyWeightObjs[upLoadType];
 			};
 			return createdFlyWeightObjs[upLoadType]= new upLoad(upLoadType);
 		}
 	}
 })(); //  创建 一个上传工厂 
 var  upLoadManager=(function(){
 	var upLoadDatabase={};
 	return {
 		add:function(id,upLoadType,fileName,fileSize){
 			var flyWeightObj=upLoadFactory.create(upLoadType);
 			var dom=document.createElement('div');
 			dom.innerHTML='<span>文件名称:'+fileName+',文件大小:'+fileSize+'</span>'+'<button class="delFile">删除</button>';
 			dom.querySelector('.delFile').onclick=function(){
 				flyWeightObj.delFile(id);
 			};
 			document.body.appendChild(dom);
 			upLoadDatabase[id]={
 				fileName:fileName,
 				fileSize:fileSize,
 				dom:dom
 			};
 			return flyWeightObj 	
 		},
 		setExternalState:function(id,flyWeigthObj){
 			 var upLoadDate=upLoadDatabase[id];
 			 for(var i in upLoadDate){
 			 	flyWeigthObj[i]=upLoadDate[i];
 			 };
 		}
 	}
 })();
 var id=0;
  window.startUpload=function(upLoadType,files){
  	for(var i= 0,file;file=files[i++];){
  		var upLoadObj=upLoadManager.add(++id,upLoadType,file.fileName,file.fileSize)
  	};

  };

  startUpload('plugin',[
  {
  	fileName:'1.txt',
  	fileSize:'8000'
  },
   {
  	fileName:'2.txt',
  	fileSize:'1000'
  },
   {
  	fileName:'3.txt',
  	fileSize:'7000'
  },
   {
  	fileName:'4.txt',
  	fileSize:'4000'
  },
   {
  	fileName:'5.txt',
  	fileSize:'5000'
  }
  ])；
  Java 中的对象池 
  
  var  toolTipFactory=(function(){
 	var  toolTipPool=[];// toopTip 对象池
 	return {
 		create:function(){
 			if(toolTipPool.length===0){
 				var  div= document.createElement('div');
 				document.body.appendChild(div);
 				return div 
 			}else{
 				 return toolTipPool.shift();
 			};

 		},
 		recover:function(toolTipDom){
 			 return toolTipPool.push(toolTipDom);
 		}// 对象池的回收
 	}

 })();
 var ary=[];

 for(var i=0,str;str=['A','B'][i++];){
 	var toolTip=toolTipFactory.create();
 	toolTip.innerHTML=str;
 	ary.push(toolTip)
 };
 for(var  i=0,toolTip;toolTip=ary[i++];){
 	toolTipFactory.recover(toolTip);
 	console.log(toolTip)
 };
for(var i=0,str;str=['C','D','E','F','G','H','F'][i++];){
	var toolTip=toolTipFactory.create();
	toolTip.innerHTML=str;

};

  ```


 # 行为型模式 
 
 ## 责任链模式  （一）
 
 + 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理他为之
 + 
 ```js 
  var order500=function(orderType,pay,stock){
 	if(orderType===1&&pay===true){
 		console.log('500元定金预购卷，得到100的优惠')
 	}else{
 		return  'nextSuccessor'
 	}
 };
  var order200=function(orderType,pay,stock){
 	if(orderType===2&&pay===true){
 		console.log('200元定金预购卷，得到50的优惠')
 	}else{
 		return  'nextSuccessor'
 	}
 };
  var orderNormal=function(orderType,pay,stock){
 	if(stock>0){
 		console.log('普通购买，没有优惠')
 	}else{
 		console.log('手机库存不足')
 	}
 };
 var chain=function(fn ){
 	this.fn=fn;
 	this.successor=null;

 };
 chain.prototype.setNextSuccessor=function(successor){
 	return this.successor=successor
 };
 chain.prototype.passRequest=function(){
 	var ret= this.fn.apply(this,arguments);
 	if(ret==='nextSuccessor'){
 		return this.successor&&this.successor.passRequest.apply(this.successor,arguments)
 	};
 	return ret;
 };
 var chainOrder500=new chain(order500);
 var chainOrder200=new chain(order200);
 var chainorderNormal=new chain(orderNormal);//将处理节点 生成链条

 chainOrder500.setNextSuccessor(chainOrder200);
 chainOrder200.setNextSuccessor(chainorderNormal); // 将责任链链接
 // 实验开始 将 问题抛给第一个问题
 chainOrder500.passRequest(2,true,500);
 
 
 
  使用AOP实现责任链
  var order500=function(orderType,pay,stock){
 	if(orderType===1&&pay===true){
 		console.log('500元定金预购卷，得到100的优惠')
 	}else{
 		return  'nextSuccessor'
 	}
 };
  var order200=function(orderType,pay,stock){
 	if(orderType===2&&pay===true){
 		console.log('200元定金预购卷，得到50的优惠')
 	}else{
 		return  'nextSuccessor'
 	}
 };
  var orderNormal=function(orderType,pay,stock){
 	if(stock>0){
 		console.log('普通购买，没有优惠')
 	}else{
 		console.log('手机库存不足')
 	}
 };
 

Function.prototype.after=function(fn){
	var seft=this;
	return function(){
		var  ret =seft.apply(this,arguments);
		if(ret==='nextSuccessor'){
			return fn.apply(this,arguments);
		};
	};
};
var  order=order500.after(order200).after(orderNormal)
 	order(1,true,500)
 ```
 ## 中介者模式 (中介者还没有完成)   （二）
 + 中介者模式就是解除对象与对象之间的紧耦合关系，增加一个中介者对象后，所有的相关对象都通过中介者对象通信，而不是互相引用。
 + 当一个对象发生改变时，只需要通知中介对象即可。
 
 ```js 
 function player(name,teamColor){
  	this.name=name;
  	this.teamColor=teamColor;
  	this.state='alive'
  };
  player.prototype.win=function(){
  	console.log(this.name+'won')
  };
  player.prototype.lose=function(){
  	console.log(this.name+'lost')
  };
  player.prototype.die=function(){
  	this.state='dead';
  	playerDirector.receiveMessage('playerDead',this);
  };

  player.prototype.remove=function(){
  	playerDirector.receiveMessage('removePlayer',this);
  };
  player.prototype.changeTeam=function(color){
  		playerDirector.receiveMessage('changeTeam',this,color);

  };
  var playerFactory=function(name,teamColor){
  	var newPlayer=new player(name,teamColor);
  	playerDirector.receiveMessage('addPlayer',newPlayer);
  	return newPlayer ;
  };
  playerDirector=(function(){
  	var players={};
  	operations={};
  	operations.addPlayer=function(player){
  		var teamColor=player.teamColor;
  		players[teamColor]=players[teamColor]||[]; //没有成立就创建 
  		players[teamColor].push(player)

  	};
  	operations.removePlayer=function(player){
  		var teamColor=player.teamColor;
  		var teamPlayers=players[teamColor]||[];
  		for(var i=teamPlayers.length-1;i>=0;i--){
  			if(teamPlayers[i]===player){
  			teamPlayers.splice(i,1)	
  			};
  		};
  	};
  	operations.changeTeam=function(player,newTeamColor){
  		operations.removePlayer(player);
  		player.teamColor=newTeamColor;
  		operations.addPlayer(player);
  	};
  	operations.playerDead=function(player){
  		var teamColor=player.teamColor;// 失败队伍的颜色
  		teamPlayers=players[teamColor];// 失败的队伍
  		var all_deal=true;
  		for(var i=0,player;player=teamPlayers[i++];){
  			if(player.state!=='dead'){
  				all_deal=false;
  				break
  			};
  		};
  		if(all_deal===true){
  			for(var i=0,player;player=teamPlayers[i++];){
  				player.lose();

  			};
  			for(var color in players){
  				if(color!==teamColor){
  					var teamPlayers=players[color];
  					for(var i=0,player;player=teamPlayers[i++];){
  						player.win();
  					}
  				}
  			}
  		}
  	};
  	var  receiveMessage=function(){
  		var message=Array.prototype.shift.call(arguments);
  		operations[message].apply(this,arguments);

  	};
  	return {
  		receiveMessage:receiveMessage
  	}

  })();
  var player1=playerFactory('皮蛋','red');
  var player2=playerFactory('小乖','red');
  var player3=playerFactory('曹合','red');
  var player4=playerFactory('杜佳','red');
  var player5=playerFactory('我还','blue');
  var player6=playerFactory('不是','blue');
  var player7=playerFactory('完美','blue');
  var player8=playerFactory('快乐','blue');

  // player1.remove();
  // player2.remove();
  // player3.die();
  // player4.die();


  player1.changeTeam('blue');
  player2.die();
  player3.die();
  player4.die();
 
 
 ```
 
 ## 状态模式 （最好使用的模式）  （三）
 
 +  实现一个电灯的模式
 + 实现一个文件上传的模式
 ```js 
 var  offLigthState=function(light){
   	this.light=light;
   };
   offLigthState.prototype.buttonWasPressed=function(){
   	console.log('弱光');
   	this.light.setState(this.light.weakLightState);// 切换到弱光
   };
   var  weakLightState=function(light){
   	this.light=light;
   };
   weakLightState.prototype.buttonWasPressed=function(){
   	console.log('强光');
   	this.light.setState(this.light.strongLightState);// 切换到强光
   };
   var  strongLightState=function(light){
   	this.light=light;
   };
   strongLightState.prototype.buttonWasPressed=function(){
   	console.log('关闭灯光');
   	this.light.setState(this.light.offLigthState);// 关闭灯光
   };

   var light=function(){
   	this.offLigthState= new offLigthState(this);
   	this.weakLightState= new weakLightState(this);
   	this.strongLightState= new strongLightState(this);
   	this.button=null;
   };
   light.prototype.init=function(){
   	var self=this;
   	var button=document.createElement('button');
   	this.button=document.body.appendChild(button);
   	this.button.innerHTML='开关';
   	this.currState=this.offLigthState;
   	this.button.onclick=function(){
   		self.currState.buttonWasPressed();

   	};
   };
   light.prototype.setState=function(newState){
   		this.currState=newState;
   };
   var light= new light();
   light.init();
   
   
   
   
  文件上传
  //现在使用的状态模式 未完成
   
  window.external.upload=function(state){
  	console.log(state);
  	// 可能的值是sign  uploading done error 
  };

  var plugin =(function(){
  	var plugin =document.createElement('embed');
  	plugin.style.display='none';
  	plugin.type='application/txftn-webkit';
  	plugin.sign=function(){
  		console.log('文件是扫描中')
  	};
  	plugin.pause=function(){
  		console.log('文件暂停')
  	};
  	plugin.uploading=function(){
  		console.log('文件上传中')
  	};
  	plugin.del=function(){
  		console.log('删除文件')
  	};
  	plugin.done=function(){
  		console.log('文件上传完成')
  	};
  	document.body.appendChild(plugin);
  	return  plugin 

  })();
  var upload=function(fileName){
  	this.plugin=plugin;
  	this.fileName=fileName;
  	this.button1=null;
  	this.button2=null;
  	this.signState=new signState(this);
  	this.uploadingState=new uploading(this);
  	this.pauseState= new pauseState(this);
  	this.doneState= new doneState(this);
  	this.errot= new  errorState(this);
  	this.currState= this.sginState;// 设置当前的状态


  };
  upload.prototype.init=function(){
  	var self=this;
  	this.dom=document.createElement('div');
  	this.dom.innerHTML=`<span>文件名称:+this.fileName+</span>
  						<button data-action='button1'>文件扫描</button>
  						<button data-action='button2'>删除</button>`;
  	document.body.appendChild(this.dom)	;	
  	this.button1=this.dom.querySelector("[data-action='button1']");
  	this.button2=this.dom.querySelector("[data-action='button2']");
  	this.bindEvent();
  };
  upload.prototype.bindEvent=function(){
  	var self=this;
  	this.button1.onclick=function(){
  		self.currState.clickHander1();

  	};
  	this.button2.onclick=function(){
  		self.currState.clickHander2();

  	};p 
  };
  upload.prototype.sign=function(){
  	this.plugin.sign();
  	this.currState=this.signState

  };
  upload.prototype.uploading=function(){
  	this.button1.innerHTML='正在上传，点击暂停';
  	this.plugin.uploading();
  	this.currState=this.uploadingState;
   
  };
   upload.prototype.pause=function(){
  	this.button1.innerHTML='以暂停，点击继续上传'; 
  	this.plugin.pause();
  	this.currState=this.pauseState;

  };
   upload.prototype.done=function(){
  	this.button1.innerHTML='上传完成';
  	this.plugin.done();
  	this.currState=this.doneState;

  };
  upload.prototype.error=function(){
  	this.button1.innerHTML='上传失败';
  	this.currState=this.errorState;

  };
  upload.prototype.del=function(){
  	this.plugin.del();
  	this.dom.parentNode.removeChild(this.dom);

  };
  var stateFactory=(function(){
  	var state=function(){};
  	state.prototype.clickHander1=function(){
  		throw new Error('子类必须重写父类的clickHandle1方法')
  	};
  	state.prototype.clickHander2=function(){
  		throw new Error('子类必须重写父类的clickHandle2方法')
  	};
  	return function(param){
  		var  F =function(uploadObj){
  			this.
  		}
  	}
  })

 ```
 
 ## 策略模式  （四）
 
 + 策略模式就是用来封装一些算法的模式
 
 + 策略模式的程序至少由两部分组成，第一部分是一组策略类策略类封装了具体的算法，并负责具体的计算过程
 
 + 第二部分是环境类context context接受客户的请求随后把请求委托给某一个策略类 
 
 + 结构上看 他与状态模式很像，也是在内部封装一些对象，然后通过返回的接口对象现实对内部对象的调用，不同的是，策略模式不需要管理状态，
 状态间没有依赖关系，策略之间可以相互替代，在策略对象的内部保存的是相互独立的一些算法。
 
 
 ```js
   var   strategies={
     	"S":function(salary){
     		return salary*4
     	},
     	"A":function(salary){
     		return salary*3
     	},
     	"B":function(salary){
     		return salary*2
     	}
     };
      var  calculateBonus=function(level,salary){
      	return strategies[level](salary)

      };
      console.log(calculateBonus("S",2000)
      var priceStrategy=(function(){ // 价格策略对象
 	// 内部算法对象 
 	var stragtegy={
 		return30:function(price){
 			return price + parseInt(price/100)*30
 		},
 		return50:function(price){
 			console.log(parseInt(price/100)*50+price)
 			return price + parseInt(price/100)*50
 		},
 		percent90:function(price){
 			return price*100*90/10000
 		},
 		percent80:function(price){
 			return price*100*80/10000
 		},
 		percent50:function(price){
 			return price*100*50/10000
 		}

 	};
 	 return function(algorithm,price){
 	 	return stragtegy[algorithm]&&stragtegy[algorithm](price)
 	 }

 }());
 var price =priceStrategy('return50',314.87);
 					

 ```
 ## 观察模式 （五）
 + 既可以在异步编程中，也可以帮助我们完成更松藕的代码编程 
 + 优点非常明显：一 时间上的解耦，二为对象之间的解耦。它的应用非常广泛 
 + 创建订阅者本身要消耗一定时间和内存，而且当你订阅一个消息后 也许此消息最后都未发生,但这个订阅者会始终存在内存中  而且弱化了对象之间的联系 
 

 ```js 
 var  salesOffices={};
 salesOffices.clientList=[];
 salesOffices.listen=function(fn){
 	//增加订阅者 
 	this.clientList.push(fn);

 };
 salesOffices.trigger=function(){
 	for(var i=0,fn;fn=this.clientList[i++];){
 		fn.apply(this,arguments);
 		//arguments 是发布消息时带上的参数
 	}
 };
 salesOffices.listen(function(price,squareMeter){
 	// 小明订阅消息
 	console.log('小明订阅消息')
 	console.log('价格'+price);
 	console.log('squareMeter='+squareMeter)

 });
 salesOffices.listen(function(price,squareMeter){
 	// 小红订阅消息
 	console.log('小红订阅消息')
 	console.log('价格='+price);
 	console.log('squareMeter='+squareMeter);

 });
 salesOffices.trigger(200000,88);  // 发送订阅的消息

 salesOffices.trigger(300000,110); 
 
 
 // 分类订阅
 var  salesOffices={};


 salesOffices.clientList={};// 缓存列表存放消息 
 salesOffices.listen=function(key,fn){
 	//增加订阅者 
 	if(!this.clientList[key]){
 		this.clientList[key]=[];
 	};
 	this.clientList[key].push(fn);
 };
 salesOffices.trigger=function(){
 	// 发送消息
 	var key= Array.prototype.shift.call(arguments);
 	fns=this.clientList[key];
 	if(!fns||fns.length===0){
 		return false
 	}
 	for(var i=0,fn;fn=fns[i++];){
 		fn.apply(this,arguments);
 		//arguments 是发布消息时带上的参数
 	}
 };
 salesOffices.listen('squareMeter88',function(price,squareMeter){
 	// 小明订阅消息
 	console.log('小明订阅消息')
 	console.log('价格'+price);
 	console.log('squareMeter='+squareMeter)

 });
 salesOffices.listen('squareMeter110',function(price,squareMeter){
 	// 小红订阅消息
 	console.log('小红订阅消息')
 	console.log('价格='+price);
 	console.log('squareMeter='+squareMeter);

 });
 salesOffices.trigger('squareMeter88',200000,4510);  // 发送订阅的消息

 salesOffices.trigger('squareMeter110',300000,7810); 
 
 
 
 
 登录网页的 消息订阅 
 $.ajax('http://xxx.com?login',function(data){
		login.trigger('loginSuncc',data);  // 发布登录成功的的消息
});
var header=(function(){
	login.listen('loginSuncc',function(data){
		header.setAvatar(data.avatar)
	};
	return {
		setAvatar:function(data){
			console.log('设置header 模块的头像 ')

		}
	}
})(); 
 // head 模块 
var nav=(function(){
	login.listen('loginSuncc',function(data){
		nav.setAvatar(data.avatar)
	};
	return {
		setAvatar:function(avatar){
			console.log('设置nav  模块的头像 ')

		}
	}
})();
// nav 模块
//后期想添加的模块 
var address=(function(){
	login.listen('loginSuncc',function(obj){
		address.refresh(obj)
	};
	return {
		refresh :function(avatar){
			console.log('刷新收货的地址列表 ')

		}
	}
})();
 
 ```
 
 
 ## 命令模式  （六）
```js 
var setCommand=function(button,command){
	button.onclick=function(){
		command.execute();
	};
};
var  menuBar={
	refresh:function(){
		console.log('刷新菜单目录');
	}
};
var subMenu={
	add:function(){
		console.log('增加子菜单')
	},
	del:function(){
		console.log('删除')
	}
};
var  refreshMenuCommand=function(){
	this.receiver=receiver;
};
refreshMenuCommand.prototype.execute=function(){
	this.execute=function(){
		this.receiver.refresh();
	}
};
var  addSubMenuCommand=function(receiver){
	this.reveiver=receiver;

};
addSubMenuCommand.prototype.execute=function(){
	this.receiver.add();
};

var  delSubMenuCommand=function (receiver){
	this.receiver=receiver;
};
delSubMenuCommand.prototype.execute=function(){
	console.log('删除子菜单')
}

 var  refreshMenuCommandO=new refreshMenuCommand(menuBar);
 var  addSubMenuCommandO= new addSubMenuCommand(subMenu);
 var  delSubMenuCommandO= new delSubMenuCommand(subMenu);
 setCommand(button1,refreshMenuCommandO);
 setCommand(button2,addSubMenuCommandO);
 setCommand(button3,delSubMenuCommandO);
 
```
 
##  模板方法模式 （七 基于继承的设计模式  ） 
 
+  模板方法模式是一种只需要使用继承就可以实现的非常简单的模式 
+ 模板方法模式由两部分结构组成 第一部分是抽象父类 第二部分是具体的实现子类 通常在抽象父类中封装子类的算法框架 
+  抽象出一个对象来 ，具体例子是茶和咖啡

	 泡咖啡          泡茶 
     把水煮沸         把水煮沸 						把水煮沸 
     用沸水冲泡咖啡   用沸水浸泡茶叶   =====>>>>>>  用沸水冲泡饮料 
     把咖啡倒进杯子   把茶叶倒进杯子 				将饮料倒进杯子
     加糖和牛奶       加柠檬 						添加调料 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
