


### 面向对象





+ 面向对象编程以数据为核心，所以在多线程并发编程中，多个线程同时操作数据的时候可能会导致数据修改的不确定性。

+ 面向对象虽然开发效率高但是代码的运行效率比起面向过程要低很多，这也限制了面向对象的使用场景不能包括那些对性能要求很苛刻的地方。

设计模式(23)

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。



 #### 单例模式
 
 > 保证一个类仅有一个实例，并提供一个访问它的全局访问点
 >> 单例是一个常见的模式，一些对象我们往往只需要一个，比如线程池 全局缓存 浏览器中的window 对象
 
 
 ##### 单例实例
 ```js
      var singLeton=function(name){
      this.name=name;
      this.instance=null;
     };
     singLeton.prototype.getName=function(){
      alter(this.name);
     };
     singLeton.getInstance=function(name){
      if (!this.instance) {
       this.instance=new singLeton(name)
      };
      return this.instance;

     };
     var a=singLeton.getInstance('sven1');
     var b=singLeton.getInstance('sven2');
     console.log(a==b)// true
 ```
 ##### 透明的单例模式
 用户从这类中创建对象的时候，可以像使用其他任何普通类一样
 
 ``` js 
 var  creatDiv=(function(){
            var instance ;
            var creatDiv=function(html){
             if(instance){
              return instance
             };
             this.init();
             return instance=this;
            }
            creatDiv.prototype.init=function(){
                   var  div=document.createElement('div');
                   div.innerHTML=this.html;
                   document.body.appendChild(div);
                  }
             return creatDiv
  })();
  var  a= new creatDiv('sven1');
  var  b= new creatDiv('sven2');
  console.log(a===b) //true 
 ```
 ##### 缓存代理的应用
 
 ```JS
            var createDiv=function(html){
            this.html=html;
            this.init();
           };
           createDiv.prototype.init=function(){
            var  div=document.createElement('div');
              div.innerHTML=this.html;
              document.body.appendChild(div);
             } ;
            proxySingDiv=(function(){
             var instance
              return function(html){
               if(!instance){
                instance=new  createDiv(html)
               }
               return instance
              }
            })();
            var a= new proxySingDiv('save1');
            var b= new proxySingDiv('save2');
           console.log(a===b)

 ```
 
